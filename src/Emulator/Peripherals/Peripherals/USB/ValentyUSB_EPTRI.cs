#define DEBUG_PACKETS
//
// Copyright (c) 2010-2019 Antmicro
//
// This file is licensed under the MIT License.
// Full license text is available in 'licenses/MIT.txt'.
//

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using Antmicro.Renode.Core;
using Antmicro.Renode.Core.Structure.Registers;
using Antmicro.Renode.Core.USB;
using Antmicro.Renode.Logging;
using Antmicro.Renode.Utilities;
using Antmicro.Renode.Utilities.Packets;

namespace Antmicro.Renode.Peripherals.USB
{
    public class ValentyUSB_EPTRI : BasicDoubleWordPeripheral, IUSBDevice, IKnownSize
    {
        public ValentyUSB_EPTRI(Machine machine, int maximumPacketSize = 64) : base(machine)
        {
            maxPacketSize = maximumPacketSize;
            USBCore = new USBDeviceCore(this);
            USBCore.ControlEndpoint.CustomSetupPacketHandler = (packet, callback, data) => SetupPacketHandler(0, packet, callback, data);

            setupPacketResultCallbackEmpty = new ManualResetEvent(true);

            eventsQueue = new Queue<Tuple<EventType, Action>>();

            masterToSlaveWaitingBuffer = new Queue<byte>[outEndpointsCount];
            for(var i = 0; i < masterToSlaveWaitingBuffer.Length; i++)
            {
                masterToSlaveWaitingBuffer[i] = new Queue<byte>();
            }

            for(byte i = 1; i < outEndpointsCount; i++)
            {
                var j = i;
                var ep = new USBEndpoint(USBCore,
                        identifier: j,
                        direction: Direction.HostToDevice,
                        transferType: EndpointTransferType.Bulk, // this doesn't matter as the descriptors are generated by the SW anyway
                        maximumPacketSize: 64, // ?! - this might be a problem
                        interval: 0 // ?!
                        );

                ep.CustomSetupPacketHandler = (packet, callback, data) => SetupPacketHandler(j, packet, callback, data);
                ep.DataWritten += data => OutDataHandler(j, data);

                USBCore.AddEndpoint(ep);
            }

            inEndpoints = new List<USBEndpoint>();
            for(byte i = 1; i < inEndpointsCount; i++)
            {
                var j = i;
                var ep = new USBEndpoint(USBCore,
                        identifier: j,
                        direction: Direction.DeviceToHost,
                        transferType: EndpointTransferType.Bulk, // this doesn't matter as the descriptors are generated by the SW anyway
                        maximumPacketSize: 64, // ?! - this might be a problem
                        interval: 0 // ?!
                        );

                ep.CustomSetupPacketHandler = (packet, callback, data) => SetupPacketHandler(j, packet, callback, data);
                ep.ReadRequest = _ => HandleReadRequest(j);

                USBCore.AddEndpoint(ep);
                inEndpoints.Add(ep);
            }

            DefineRegisters();
        }

        public void HandleReadRequest(int epno)
        {
            this.Log(LogLevel.Noisy, "Handling READ request on EP#{0}", epno);

            SetNextEvent(EventType.In);
            inEventDonePendingField.Value = true;
            UpdateInterrupts();
        }

        public override void Reset()
        {
            base.Reset();

            slaveToMasterBufferVirtualBase = 0;

            setupPacketBuffer.Clear();
            masterToSlaveBuffer.Clear();
            slaveToMasterBuffer.Clear();

            for(var i = 0; i < outEndpointsCount; i++)
            {
                masterToSlaveWaitingBuffer[i].Clear();
            }

            eventsQueue.Clear();
            nextEvent = null;
        }

        public long Size => 0x100;

        public USBDeviceCore USBCore { get; }

        public GPIO IRQ { get; } = new GPIO();

        protected void DefineRegisters()
        {
            Registers.PullupOut.Define(this)
                .WithFlag(0, name: "PULLUP_OU")
                .WithReservedBits(1, 7)
                .WithWriteCallback((_, v) =>
                {
                    if(v != 0)
                    {
                        // pull-up will be set when enabling
                        // the device, so it's a good moment
                        // to simulate RESET condition
                        setupEventResetPendingField.Value = true;
                        SetNextEvent(EventType.Reset);
                        UpdateInterrupts();
                    }
                })
            ;

            Registers.Address.Define(this)
                .WithValueField(0, 7, name: "ADDR",
                    writeCallback: (_, val) => { USBCore.Address = (byte)val; },
                    valueProviderCallback: _ => USBCore.Address)
                .WithReservedBits(7, 1)
            ;

            Registers.NextEvent.Define(this)
                // this is a combination of IN/OUT/SETUP/RESET flags
                .WithValueField(0, 4, FieldMode.Read, valueProviderCallback: _ =>
                {
                    lock(eventsQueue)
                    {
                        TryAdvanceToTheNextEvent();
                        return (nextEvent == null)
                            ? 0
                            : (uint)(1 << ((int)nextEvent.Item1 - 1));
                    }
                })
                .WithReservedBits(4, 4)
            ;

            Registers.SetupData.Define(this)
                .WithValueField(0, 8, FieldMode.Read, name: "DATA",
                    valueProviderCallback: _ =>
                    {
                        if(setupPacketBuffer.Count == 0)
                        {
                            this.Log(LogLevel.Warning, "Trying to read from an empty setup data queue");
                            return 0u;
                        }

                        var result = setupPacketBuffer.Dequeue();
                        this.Log(LogLevel.Noisy, "Reading byte from setup data buffer: 0x{0:X}. Bytes left: {1}", result, setupPacketBuffer.Count);
                        return result;
                    })
            ;

            Registers.SetupControl.Define(this)
                .WithReservedBits(0, 5)
                .WithTag("RESET", 5, 1)
                .WithReservedBits(6, 2)
            ;

            Registers.SetupStatus.Define(this)
                .WithValueField(0, 4, out setupStatusEndpointNumberField, name: "EPNO")
                .WithFlag(4, FieldMode.Read, name: "HAVE", valueProviderCallback: _ => setupPacketBuffer.Any())
                .WithFlag(5, FieldMode.Read, name: "PEND", valueProviderCallback: _ => setupEventReadyPendingField.Value || setupEventResetPendingField.Value)
                .WithTag("IS_IN", 6, 1)
                .WithTag("DATA", 7, 1)
            ;

            Registers.SetupEventStatus.Define(this)
                .WithFlag(0, FieldMode.Read, name: "READY", valueProviderCallback: _ => setupEventReadyPendingField.Value)
                .WithFlag(1, FieldMode.Read, name: "RESET", valueProviderCallback: _ => setupEventResetPendingField.Value)
                .WithReservedBits(2, 6)
            ;

            Registers.SetupEventPending.Define(this)
                .WithFlag(0, out setupEventReadyPendingField, FieldMode.Read | FieldMode.WriteOneToClear, name: "READY")
                .WithFlag(1, out setupEventResetPendingField, FieldMode.Read | FieldMode.WriteOneToClear, name: "RESET")
                .WithWriteCallback((_, val) =>
                {
                    UpdateInterrupts();
                    TryAdvanceToTheNextEvent(force: true);
                })
            ;

            Registers.SetupEventEnable.Define(this)
                .WithFlag(0, out setupEventReadyEnabledField, name: "READY")
                .WithFlag(1, out setupEventResetEnabledField, name: "RESET")
                .WithWriteCallback((_, val) => UpdateInterrupts())
            ;

            Registers.InData.Define(this)
                .WithValueField(0, 8, name: "DATA",
                    valueProviderCallback: _ =>
                    {
                        if(slaveToMasterBuffer.Count == 0)
                        {
                            this.Log(LogLevel.Warning, "Trying to read from an empty IN fifo");
                            return 0u;
                        }

                        var result = slaveToMasterBuffer.Dequeue();
                        this.Log(LogLevel.Noisy, "Reading byte from IN fifo: 0x{0:X} (bytes left: {1})", result, slaveToMasterBuffer.Count);
                        return result;
                    },
                    writeCallback: (_, val) => 
                    {
                        slaveToMasterBuffer.Enqueue((byte)val);

                        if(slaveToMasterBuffer.Count - slaveToMasterBufferVirtualBase > FifoSize)
                        {
                            this.Log(LogLevel.Warning, "IN fifo overflow detected - initial byte will be dropped, expect problems");
                            slaveToMasterBuffer.Dequeue();
                        }
                    })
            ;

            Registers.InControl.Define(this)
                .WithValueField(0, 4, out var epnoField, name: "EPNO")
                .WithReservedBits(4, 1)
                .WithFlag(5, out inResetFlag, name: "RESET")
                .WithFlag(6, out inStallFlag, name: "STALL")
                .WithReservedBits(7, 1)
                .WithWriteCallback((_, __) =>
                {
                    if(inResetFlag.Value)
                    {
                        this.Log(LogLevel.Noisy, "Resetting IN fifo");
                        slaveToMasterBufferVirtualBase = 0;
                        slaveToMasterBuffer.Clear();
                    }

                    if(inStallFlag.Value)
                    {
                        this.Log(LogLevel.Debug, "Endpoint #{0} stalled", epnoField.Value);
                        if(setupPacketResultCallback == null)
                        {
                            return;
                        }
                        SendSetupPacketResponse((int)epnoField.Value, stall: true);
                    }

                    if(!inResetFlag.Value && !inStallFlag.Value)
                    {
                        ProduceDataToMaster((int)epnoField.Value);
                    }
                })
            ;

            Registers.InStatus.Define(this)
                .WithFlag(0, FieldMode.Read, name: "IDLE", valueProviderCallback: _ => true)
                .WithReservedBits(1, 3)
                .WithFlag(4, FieldMode.Read, name: "HAVE", valueProviderCallback: _ => slaveToMasterBuffer.Count > 0)
                .WithFlag(5, FieldMode.Read, name: "PEND", valueProviderCallback: _ => inEventDonePendingField.Value)
                .WithReservedBits(6, 2)
            ;

            Registers.InEventStatus.Define(this)
                .WithFlag(0, FieldMode.Read, name: "DONE", valueProviderCallback: _ => inEventDonePendingField.Value)
                .WithReservedBits(1, 7)
            ;

            Registers.InEventPending.Define(this)
                .WithFlag(0, out inEventDonePendingField, FieldMode.Read | FieldMode.WriteOneToClear, name: "DONE")
                .WithReservedBits(1, 7)
                .WithWriteCallback((_, val) =>
                {
                    UpdateInterrupts();
                    TryAdvanceToTheNextEvent(force: true);
                })
            ;

            Registers.InEventEnable.Define(this)
                .WithFlag(0, out inEventDoneEnabledField, name: "DONE")
                .WithReservedBits(1, 7)
                .WithWriteCallback((_, val) => UpdateInterrupts())
            ;

            Registers.OutData.Define(this)
                .WithValueField(0, 8, FieldMode.Read, name: "DATA",
                    valueProviderCallback: _ =>
                    {
                        if(masterToSlaveBuffer.Count == 0)
                        {
                            this.Log(LogLevel.Warning, "Trying to read from an empty OUT fifo");
                            return 0u;
                        }

                        var result = masterToSlaveBuffer.Dequeue();
                        this.Log(LogLevel.Noisy, "Reading byte from OUT fifo: 0x{0:X} (bytes left: {1})", result, masterToSlaveBuffer.Count);
                        return result;
                    })
            ;

            Registers.OutControl.Define(this)
                .WithValueField(0, 4, out var epnoNumber, name: "EPNO")
                .WithFlag(4, out outControlEnableFlag, name: "ENABLE")
                .WithFlag(5, out outResetFlag, name: "RESET")
                .WithFlag(6, out outStallFlag, name: "STALL")
                .WithReservedBits(7, 1)
                .WithWriteCallback((_, __) =>
                {
                    if(outControlEnableFlag.Value)
                    {
                        lock(masterToSlaveBuffer)
                        {
                            // setting enable to true means that the device
                            // is ready for the data from master
                            PrepareDataFromMaster((int)epnoNumber.Value, force: false);
                        }
                    }

                    if(outStallFlag.Value)
                    {
                        outStallFlag.Value = false;
                    }
                })
            ;

            Registers.OutStatus.Define(this)
                .WithValueField(0, 4, out outStatusEpNo, name: "EPNO")
                .WithFlag(4, FieldMode.Read, name: "HAVE", valueProviderCallback: _ => masterToSlaveBuffer.Any())
                .WithFlag(5, FieldMode.Read, name: "PEND", valueProviderCallback: _ => outEventDonePendingField.Value)
                .WithReservedBits(6, 2)
            ;

            Registers.OutEventStatus.Define(this)
                .WithFlag(0, FieldMode.Read, name: "DONE", valueProviderCallback: _ => outEventDonePendingField.Value)
                .WithReservedBits(1, 7)
            ;

            Registers.OutEventPending.Define(this)
                .WithFlag(0, out outEventDonePendingField, FieldMode.Read | FieldMode.WriteOneToClear, name: "DONE")
                .WithReservedBits(1, 7)
                .WithWriteCallback((_, val) =>
                {
                    UpdateInterrupts();
                    TryAdvanceToTheNextEvent(force: true);
                })
            ;

            Registers.OutEventEnable.Define(this)
                .WithFlag(0, out outEventDoneEnabledField, name: "DONE")
                .WithReservedBits(1, 7)
                .WithWriteCallback((_, val) => UpdateInterrupts())
            ;
        }

        public void ProduceDataToMaster(int epno)
        {
            this.Log(LogLevel.Noisy, "Producing data to master on EP#{0}", epno);

            if(epno == 0)
            {
                var chunkSize = slaveToMasterBuffer.Count - slaveToMasterBufferVirtualBase;
                slaveToMasterBufferVirtualBase = slaveToMasterBuffer.Count;

                // IN packet pending means that the master is waiting for more data
                // and slave should generate it
                SetNextEvent(EventType.In);
                inEventDonePendingField.Value = true;
                UpdateInterrupts();

                if(chunkSize < maxPacketSize)
                {
                    this.Log(LogLevel.Noisy, "Data chunk was shorter than max packet size (0x{0:X} vs 0x{1:X}), so this is the end of data", chunkSize, maxPacketSize);
                    SendSetupPacketResponse(epno);
                }
            }
            else
            {
                var ep = inEndpoints[epno - 1];
                using(var p = ep.PreparePacket())
                {
                    this.Log(LogLevel.Noisy, "Buffer size : {0}", slaveToMasterBuffer.Count);
                    var endOfPacketDetected = slaveToMasterBuffer.Count < maxPacketSize;

                    while(slaveToMasterBuffer.Count > 0)
                    {
                        p.Add(slaveToMasterBuffer.Dequeue());
                    }

                    if(!endOfPacketDetected)
                    {
                        SetNextEvent(EventType.In);
                        inEventDonePendingField.Value = true;
                        UpdateInterrupts();
                    }
                }
            }
        }

        private void SendSetupPacketResponse(int epno, bool stall = false)
        {
            if(masterToSlaveWaitingBuffer[epno].Count != 0)
            {
                this.Log(LogLevel.Error, "Setup packet handling finished, but there is still some unhandled additional data left. Dropping it, but expect problems");
                masterToSlaveWaitingBuffer[epno].Clear();
            }

            this.Log(LogLevel.Noisy, "Setup packet at EP #{0} handled", epno);
#if DEBUG_PACKETS
            this.Log(LogLevel.Noisy, "Response bytes: [{0}]", Misc.PrettyPrintCollection(slaveToMasterBuffer, b => b.ToString("X")));
#endif
            slaveToMasterBufferVirtualBase = 0;

            if(setupPacketResultCallback == null)
            {
                this.Log(LogLevel.Error, "No setup packet is handled at the moment, but the software wants to send data back. It might indicate a faulty driver");
                return;
            }

            // we skip the status stage when there was a stall
            if(stall)
            {
                // clear the buffer, but do not send any data
                slaveToMasterBuffer.DequeueAll();
                // send null to indicate the stall condition
                setupPacketResultCallback(null);
                setupPacketResultCallback = null;
                setupPacketResultCallbackEmpty.Set();
            }
            else if(isIn)
            {
                this.Log(LogLevel.Noisy, "IN control transfer - finishing it with OUT status stage");
                SetNextEvent(EventType.Out, () =>
                {
                    var responseData = slaveToMasterBuffer.DequeueAll();
                    setupPacketResultCallback(responseData);
                    setupPacketResultCallback = null;
                    setupPacketResultCallbackEmpty.Set();
                });

                outControlEnableFlag.Value = false;
                outEventDonePendingField.Value = true;
                UpdateInterrupts();
            }
            else
            {
                this.Log(LogLevel.Noisy, "OUT control transfer - finishing it with IN status stage");
                SetNextEvent(EventType.In, () =>
                {
                    var responseData = slaveToMasterBuffer.DequeueAll();
                    setupPacketResultCallback(responseData);
                    setupPacketResultCallback = null;
                    setupPacketResultCallbackEmpty.Set();
                });

                inEventDonePendingField.Value = true;
                UpdateInterrupts();
            }
        }

        private void PrepareDataFromMaster(int epno, bool force)
        {
            if(!force && masterToSlaveWaitingBuffer[epno].Count == 0)
            {
                this.Log(LogLevel.Noisy, "Asked to prepare data from master, but there is none...");
                return;
            }

            var chunk = masterToSlaveWaitingBuffer[epno].DequeueRange(maxPacketSize);
            this.Log(LogLevel.Noisy, "Enqueuing chunk of data to EP #{0} from HOST of size {1}", epno, chunk.Length);
            EnqueueDataFromMaster(epno, chunk);
        }

        private void EnqueueSetupFromMaster(int epno, IEnumerable<byte> data)
        {
            if(setupPacketBuffer.Count != 0)
            {
                this.Log(LogLevel.Warning, "Stale SETUP data in the buffer detected - it might indicate problems with the driver");
                setupPacketBuffer.Clear();
            }

            setupPacketBuffer.EnqueueRange(data);

            // fake 16-bit CRC
            setupPacketBuffer.Enqueue(0);
            setupPacketBuffer.Enqueue(0);

            this.Log(LogLevel.Noisy, "Enqueued SETUP packet for endpoint #{0}", epno);

            setupStatusEndpointNumberField.Value = (uint)epno;
            SetNextEvent(EventType.Setup);
            setupEventReadyPendingField.Value = true;
            UpdateInterrupts();
        }

        private void OutDataHandler(int epno, IEnumerable<byte> data)
        {
            lock(masterToSlaveBuffer)
            {
                masterToSlaveWaitingBuffer[epno].EnqueueRange(data);
                if(outControlEnableFlag.Value)
                {
                    PrepareDataFromMaster(epno, force: true);
                }
            }
        }

        private void EnqueueDataFromMaster(int epno, IEnumerable<byte> data)
        {
            lock(masterToSlaveBuffer)
            {
                outStatusEpNo.Value = (uint)epno;
                masterToSlaveBuffer.EnqueueRange(data);

                // fake 16-bit CRC
                masterToSlaveBuffer.Enqueue(0);
                masterToSlaveBuffer.Enqueue(0);

                SetNextEvent(EventType.Out);

                outControlEnableFlag.Value = false;
                outEventDonePendingField.Value = true;
                UpdateInterrupts();
            }
        }

        private void SetNextEvent(EventType t, Action a = null)
        {
            this.Log(LogLevel.Noisy, "Enqueuing next event to {0}", t);
            lock(eventsQueue)
            {
                eventsQueue.Enqueue(Tuple.Create(t, a));
                TryAdvanceToTheNextEvent();
            }
        }

        private bool TryAdvanceToTheNextEvent(bool force = false)
        {
            lock(eventsQueue)
            {
                if(!force && nextEvent != null)
                {
                    this.Log(LogLevel.Noisy, "The previous event {0} is still valid", nextEvent.Item1);
                    return false;
                }

                if(eventsQueue.Count == 0)
                {
                    nextEvent = null;
                    return false;
                }

                nextEvent = eventsQueue.Dequeue();

                nextEvent.Item2?.Invoke();

                this.Log(LogLevel.Noisy, "The new event is {0}", nextEvent.Item1);
                return true;
            }
        }

        private void UpdateInterrupts()
        {
            var irqState =
                   (setupEventReadyPendingField.Value && setupEventReadyEnabledField.Value)
                || (setupEventResetPendingField.Value && setupEventResetEnabledField.Value)
                || (inEventDonePendingField.Value && inEventDoneEnabledField.Value)
                || (outEventDonePendingField.Value && outEventDoneEnabledField.Value);

            IRQ.Set(irqState);
            this.Log(LogLevel.Noisy, "Setting IRQ to {0}", irqState);
        }

        private void SetupPacketHandler(int epno, SetupPacket packet, Action<byte[]> resultCallback, byte[] additionalData)
        {

            // TODO: this is a hack too!
            this.Log(LogLevel.Noisy, "Waiting for previous setup to finish");
            setupPacketResultCallbackEmpty.WaitOne();
            this.Log(LogLevel.Noisy, "No previous setup - we can go!");

            this.Log(LogLevel.Noisy, "Received setup packet: {0} on endpoint #{1}", packet.ToString(), epno);

            if(setupPacketResultCallback != null)
            {
                this.Log(LogLevel.Error, "Setup packet result handler is set. It means that the previous setup packet handler has not yet finished. Expect problems!");
            }
            setupPacketResultCallback = resultCallback;
            setupPacketResultCallbackEmpty.Reset();
            isIn = (packet.Direction == Direction.DeviceToHost);

            setupPacketBuffer.Clear();

            var packetBytes = Packet.Encode(packet);
#if DEBUG_PACKETS
            this.Log(LogLevel.Noisy, "Setup packet bytes: [{0}]", Misc.PrettyPrintCollection(packetBytes, b => b.ToString("X")));
#endif
            EnqueueSetupFromMaster(epno, packetBytes);

            if(additionalData != null)
            {
                this.Log(LogLevel.Noisy, "This packets comes with additional data!");

#if DEBUG_PACKETS
                this.Log(LogLevel.Noisy, "Additional bytes: [{0}]", Misc.PrettyPrintCollection(additionalData, z => z.ToString("X")));
#endif
                OutDataHandler(epno, additionalData);
            }
        }

        private readonly ManualResetEvent setupPacketResultCallbackEmpty;

        private Action<byte[]> setupPacketResultCallback;
        private bool isIn;

        private IValueRegisterField setupStatusEndpointNumberField;

        private IFlagRegisterField setupEventReadyPendingField;
        private IFlagRegisterField setupEventResetPendingField;
        private IFlagRegisterField setupEventReadyEnabledField;
        private IFlagRegisterField setupEventResetEnabledField;

        private IFlagRegisterField inEventDonePendingField;
        private IFlagRegisterField inEventDoneEnabledField;

        private IFlagRegisterField outEventDonePendingField;
        private IFlagRegisterField outEventDoneEnabledField;

        private IFlagRegisterField outControlEnableFlag;
        private IValueRegisterField outStatusEpNo;

        private int slaveToMasterBufferVirtualBase;
        private IFlagRegisterField outStallFlag;
        private IFlagRegisterField outResetFlag;
        private IFlagRegisterField inStallFlag;
        private IFlagRegisterField inResetFlag;
        private readonly int maxPacketSize;

        private readonly Queue<byte> setupPacketBuffer = new Queue<byte>();
        private readonly Queue<byte> masterToSlaveBuffer = new Queue<byte>();
        private readonly Queue<byte> slaveToMasterBuffer = new Queue<byte>();

        // one queue per endpoint
        private readonly Queue<byte>[] masterToSlaveWaitingBuffer;

        private readonly Queue<Tuple<EventType, Action>> eventsQueue;

        private readonly List<USBEndpoint> inEndpoints;

        private Tuple<EventType, Action> nextEvent;

        private const int FifoSize = 64;
        private const int inEndpointsCount = 16;
        private const int outEndpointsCount = 16;

        private enum Registers
        {
            PullupOut = 0x0,
            Address = 0x04,
            NextEvent = 0x08,

            SetupData = 0x0C,
            SetupControl = 0x10,
            SetupStatus = 0x14,
            SetupEventStatus = 0x18,
            SetupEventPending = 0x1C,
            SetupEventEnable = 0x20,

            InData = 0x24,
            InControl = 0x28,
            InStatus = 0x2C,
            InEventStatus = 0x30,
            InEventPending = 0x34,
            InEventEnable = 0x38,

            OutData = 0x3C,
            OutControl = 0x40,
            OutStatus = 0x44,
            OutEventStatus = 0x48,
            OutEventPending = 0x4C,
            OutEventEnable = 0x50,

            OutEnableStatus = 0x54,
            OutStallStatus = 0x58
        }

        private enum EventType
        {
            None,
            In,
            Out,
            Setup,
            Reset
        }
    }
}
